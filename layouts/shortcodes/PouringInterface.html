<html>

	<body>

		<script>

	    // function to check if a tool is needed for the task (input: action verb, output: tool)
            async function get_needed_tool(verb) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX dul: <http://www.ontologydesignpatterns.org/ont/dul/DUL.owl#>
		    PREFIX pour: <http://www.ease-crc.org/ont/pouring_food#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		    PREFIX obo: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        ${verb} rdfs:subClassOf ?sub.
                        ?sub owl:onProperty dul:hasParticipant.
                        ?sub owl:someValuesFrom ?neededtool.
                        BIND(REPLACE(STR(?neededtool), "^.*[#/]", "") AS ?res).
                    }
                `;

            	return query_text(sparqlQuery, '')
            }
			

	    // function to query the SPARQL endpoint
            async function query_text(query, alternative) {
            	// UniB SPARQL endpoint URL
                const endpointUrl = 'http://knowledgedb.informatik.uni-bremen.de:3031/#/dataset/MealPreparation/query'

                const requestOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/sparql-query',
                    },
                    body: query,
                }

                try {
                    const response = await fetch(endpointUrl, requestOptions)
                    const data = await response.json()
                    const firstObject = data[0];
                    return firstObject.res
                } catch (error) {
                    console.error('Error:', error)
                    return alternative
                }
            }

            
		// function to get the min angle needed for the task (input: food object, output: angle)
            async function get_minangle(food) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX pour: <http://www.ease-crc.org/ont/pouring_food#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      		    PREFIX qudt: <http://qudt.org/schema/qudt#>
	  	    PREFIX obo: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        ${food} rdfs:subClassOf ?cons_node.
                        ?cons_node owl:onProperty pour:hasConsistency.
			?cons_node owl:someValuesFrom ?consistency.
                        ?union rdf:first*/rdf:rest* ?consistency.
 			 {
 			 ?rest rdf:first*/rdf:rest* ?union.
  			?start owl:unionOf ?rest.
 			 ?a owl:someValuesFrom ?start.
 			 }
 			 UNION
 			 {
 			   ?a owl:allValuesFrom ?union.
 			 }
 			 ?f rdf:first*/rdf:rest* ?a.
			  ?r rdf:first*/rdf:rest* ?f.
			  ?i owl:intersectionOf ?r.
			  ?inter owl:someValuesFrom ?i.
			  ?param rdfs:subClassOf ?inter.
			  ?param rdfs:subClassOf pour:PouringAngle.
			  ?param rdfs:subClassOf ?degree1.
			  ?degree1 owl:onProperty qudt:valueQuantity.
			  ?degree1 owl:minQualifiedCardinality ?res.
                    }
                `;

            	return query_text(sparqlQuery, '0')
            }


		// function to get the max angle needed for the task (input: food object, output: angle)
            async function get_maxangle(food) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX pour: <http://www.ease-crc.org/ont/pouring_food#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      		    PREFIX qudt: <http://qudt.org/schema/qudt#>
	    	    PREFIX obo: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        ${food} rdfs:subClassOf ?cons_node.
                        ?cons_node owl:onProperty pour:hasConsistency.
			?cons_node owl:someValuesFrom ?consistency.
                        ?union rdf:first*/rdf:rest* ?consistency.
 			 {
 			 ?rest rdf:first*/rdf:rest* ?union.
  			?start owl:unionOf ?rest.
 			 ?a owl:someValuesFrom ?start.
 			 }
 			 UNION
 			 {
 			   ?a owl:allValuesFrom ?union.
 			 }
 			 ?f rdf:first*/rdf:rest* ?a.
			  ?r rdf:first*/rdf:rest* ?f.
			  ?i owl:intersectionOf ?r.
			  ?inter owl:someValuesFrom ?i.
			  ?param rdfs:subClassOf ?inter.
			  ?param rdfs:subClassOf pour:PouringAngle.
			  ?param rdfs:subClassOf ?degree1.
			  ?degree1 owl:onProperty qudt:valueQuantity.
			  ?degree1 owl:maxQualifiedCardinality ?res.
                    }
                `;

            	return query_text(sparqlQuery, '90')
            }

			// function to get the min duration needed for the task (input: food object, output: duration)
            async function get_minduration(food) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX pour: <http://www.ease-crc.org/ont/pouring_food#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      		    PREFIX qudt: <http://qudt.org/schema/qudt#>
	    	    PREFIX obo: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        ${food} rdfs:subClassOf ?cons_node.
                        ?cons_node owl:onProperty cut:affordsPosition.
                        ?cons_node owl:someValuesFrom ?consistency.
                        ?union rdf:first*/rdf:rest* ?consistency.
			  {
			  ?rest rdf:first*/rdf:rest* ?union.
			  ?start owl:unionOf ?rest.
			  ?a owl:someValuesFrom ?start.
			  }
			  UNION
 			 {
			    ?a owl:allValuesFrom ?union.
			  }
 			 ?f rdf:first*/rdf:rest* ?a.
			  ?r rdf:first*/rdf:rest* ?f.
			  ?i owl:intersectionOf ?r.
			  ?inter owl:someValuesFrom ?i.
			  ?param rdfs:subClassOf ?inter.
			  ?param rdfs:subClassOf pour:PouringDuration.
			  ?param rdfs:subClassOf ?degree1.
			  ?degree1 owl:onProperty qudt:valueQuantity.
			  ?degree1 owl:minQualifiedCardinality ?res.
                    }
                `;

            	return query_text(sparqlQuery, '0')
            }

		// function to get the max duration needed for the task (input: food object, output: duration)
			// function to get the min duration needed for the task (input: food object, output: duration)
            async function get_maxduration(food) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX pour: <http://www.ease-crc.org/ont/pouring_food#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
		    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      		    PREFIX qudt: <http://qudt.org/schema/qudt#>
	    	    PREFIX obo: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        ${food} rdfs:subClassOf ?cons_node.
                        ?cons_node owl:onProperty cut:affordsPosition.
                        ?cons_node owl:someValuesFrom ?consistency.
                        ?union rdf:first*/rdf:rest* ?consistency.
			  {
			  ?rest rdf:first*/rdf:rest* ?union.
			  ?start owl:unionOf ?rest.
			  ?a owl:someValuesFrom ?start.
			  }
			  UNION
 			 {
			    ?a owl:allValuesFrom ?union.
			  }
 			 ?f rdf:first*/rdf:rest* ?a.
			  ?r rdf:first*/rdf:rest* ?f.
			  ?i owl:intersectionOf ?r.
			  ?inter owl:someValuesFrom ?i.
			  ?param rdfs:subClassOf ?inter.
			  ?param rdfs:subClassOf pour:PouringDuration.
			  ?param rdfs:subClassOf ?degree1.
			  ?degree1 owl:onProperty qudt:valueQuantity.
			  ?degree1 owl:maxQualifiedCardinality ?res.
                    }
                `;

            	return query_text(sparqlQuery, '10')
            }

			
            function add_to_table(number, motion, inference) {
            	var motion_table = document.getElementById("motions");
            	var row = motion_table.insertRow(-1);
                var numb = row.insertCell(0);
                var mot = row.insertCell(1);
                var inf = row.insertCell(2);
              	numb.innerHTML = number + ".";
                mot.innerHTML = motion;
                inf.innerHTML = inference;
            }

            function clear_table() {
            	var motion_table = document.getElementById("motions");
            	var rowCount = motion_table.rows.length;
                for (var i = rowCount - 1; i >= 1; i--) {
                    motion_table.deleteRow(i);
                }
            }

			async function query_and_show() {
				var container = document.getElementById("results");
				var header = document.getElementById("header");

				var verbs = document.getElementById("verb-select");
				var foods = document.getElementById("food-select");
                var selected_verb = verbs.options[verbs.selectedIndex].textContent
                var selected_food = foods.options[foods.selectedIndex].textContent

				// changing the container visibility
				container.style.display = "block";

				// changing the header
				header.textContent = "Motions for " + selected_verb + " a / an " + selected_food + ":"

                // query the ontology
                var needed_tool = await get_needed_tool(verbs.value)
		var minangle = await get_minangle(foods.value)
		var maxangle = await get_maxangle(foods.value)
		var minduration = await get_minduration(foods.value)
		var maxduration = await get_maxduration(foods.value)
             //   var shape = await get_target(verbs.value)

                // create motion list from ontology query
                clear_table()
                curr_step = 1
                target = ''

                // optional preconditions
                if (needed_tool != '') {
                	add_to_table(curr_step++, "Use the following tool for the task: " + needed_tool, "requires tool = true<br>needed tool = " + needed_tool)
                }

                // picking up the object
                add_to_table(curr_step, "Picking up the pourable object ...", "pourable object = " + selected_food)
                               

                // pouring the food object with angle
                add_to_table(curr_step, "Pouring the food object at the angle ...", "food object = " + selected_food + "<br>min angle = " + minangle + "<br>max angle = " + maxangle)
              
		// pouring the food object for duration
                add_to_table(curr_step, "Pouring the food object for the duration ...", "food object = " + selected_food + "<br>min duration = " + minduration + "<br>max duration = " + maxduration)
			}
		</script>

		Show me the plan for the following<br> <label for="food-select"><b>task</b>: </label>
		<select name="verbs" id="verb-select">
			<option value="pour:Pouring">Pour</option>
			<option value="pour:Draining">Drain</option>
			<option value="pour:Sprinkling">Sprinkle</option>
		</select>

		<label for="food-select"> the following food <b>a / an</b> </label>
		<select name="foods" id="food-select">
			<option value="obo:FOODON_03301304">batter</option>
			<option value="obo:FOODON_03420170">broth</option>
			<option value="obo:FOODON_03307240">chocolate</option>
			<option value="obo:FOODON_03301036">coffee</option>
			<option value="pour:cream">cream</option>
			<option value="obo:FOODON_03316061">egg</option>
			<option value="obo:FOODON_03302339">flour</option>
			<option value="obo:FOODON_03315552">juice</option>
			<option value="pour:Liquids">liquids</option>
			<option value="obo:UBERON_0001913">milk</option>
			<option value="obo:FOODON_03310387">oil</option>
			<option value="obo:FOODON_03311146">sauce</option>
			<option value="obo:FOODON_03301073">sugar</option>
			<option value="obo:FOODON_03303225">syrup</option>
			<option value="obo:FOODON_03315081">tea</option>
			<option value="obo:FOODON_03301705">vinegar</option>
			<option value="obo:ENVO_00003064">water</option>
			<option value="obo:FOODON_03301338">wine</option>
		</select>

		<button type="button" onclick="query_and_show()">Query</button> </font>

		<div id="results" style='display: none'>
			<p id="header"></p>
			<table id="motions">
            <tr>
              <th>#</th>
              <th>Motions</th>
              <th>Inference</th>
            </tr>
          </table>
		</div>
	</body>


</html>
